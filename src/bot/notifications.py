import os
import logging
import time
from typing import List, Dict
from ..common.config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, TELEGRAM_THREAD_ID
import requests
from telegram import Bot
import asyncio
from .analytics import get_top_asset_overall, get_top_asset_by_chain, get_top_growing_asset, get_top3_base_apy, get_latest_apy_data, get_top_apy_pools
from telegram.error import RetryAfter

logger = logging.getLogger(__name__)

class TelegramNotifier:
    def __init__(self, alert_config: dict = None):
        self.config = alert_config or {
            'send_overall': True,
            'send_chains': ['Ethereum', 'Polygon', 'Arbitrum'],
            'send_growth': False,
            'send_top3_base': True
        }
        self.bot = None  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ–∑–∂–µ
        self._growth_data = None
        
    def run_alerting(self):
        """Main alerting workflow"""
        latest_apy = get_latest_apy_data()
        top_pools = get_top_apy_pools(latest_apy, limit=5)
        
        self.send_top_asset_alerts(latest_apy)
        
        if top_pools:
            self.send_top_apy_alert(top_pools)
        
    @staticmethod
    def _escape_markdown_v2(text: str) -> str:
        """Escape special characters for MarkdownV2"""
        special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        escaped_text = ''
        for char in str(text):
            if char in special_chars:
                escaped_text += f'\\{char}'
            else:
                escaped_text += char
        return escaped_text

    async def _send_message(self, message: str) -> bool:
        """Async message sender with flood control"""
        try:
            if not TELEGRAM_CHAT_ID:
                logger.error("Telegram chat ID not configured!")
                return False
            
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä Bot –ø—Ä–∏ –∫–∞–∂–¥–æ–º –≤—ã–∑–æ–≤–µ
            self.bot = Bot(token=TELEGRAM_BOT_TOKEN)
            
            logger.info(f"Sending to chat: {TELEGRAM_CHAT_ID}, thread: {TELEGRAM_THREAD_ID}")
            
            await self.bot.send_message(
                chat_id=str(TELEGRAM_CHAT_ID),
                message_thread_id=int(TELEGRAM_THREAD_ID) if TELEGRAM_THREAD_ID else None,
                text=message,
                parse_mode='MarkdownV2',
                disable_web_page_preview=True
            )
            return True
        
        except RetryAfter as e:
            wait_time = e.retry_after
            logger.warning(f"Flood control: Waiting {wait_time}s")
            await asyncio.sleep(wait_time)
            return await self._send_message(message)  # Retry
        
        except Exception as e:
            logger.error(f"Telegram error: {type(e)} - {str(e)}")
            logger.info("Please verify:")
            logger.info(f"1. Bot is added to chat {TELEGRAM_CHAT_ID}")
            logger.info(f"2. Thread {TELEGRAM_THREAD_ID} exists")
            logger.info(f"3. Bot has 'Send Messages' permission")
            return False
        finally:
            if self.bot:
                await self.bot.close()
                await asyncio.sleep(1)  # –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é –ø–∞—É–∑—É –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è

    def send_alert(self, recommendations: List[Dict]) -> bool:
        """Main alert method"""
        if not recommendations:
            logger.info("No recommendations to send")
            return False
            
        message = self._format_recommendation(recommendations)
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(self._send_message(message))

    def _format_recommendation(self, recommendations: List[Dict]) -> str:
        """Format recommendations considering positions"""
        header = "üìä *Yield Optimization Recommendations* üìä\n\n"
        rows = []
        
        for rec in recommendations[:5]:  # Limit to top 5
            # Escape all values
            asset = self._escape_markdown_v2(rec['asset'])
            from_chain = self._escape_markdown_v2(rec['from_chain'])
            to_chain = self._escape_markdown_v2(rec['to_chain'])
            current_apy = self._escape_markdown_v2(str(rec['current_apy']))
            target_apy = self._escape_markdown_v2(str(rec['target_apy']))
            profit = self._escape_markdown_v2(str(rec['estimated_profit']))
            gas = self._escape_markdown_v2(str(rec['gas_cost']))
            position = self._escape_markdown_v2(f"{rec['position_size']:,.2f}")
            
            row = (
                f"‚Ä¢ *{asset}*: {from_chain} ‚û°Ô∏è {to_chain}\n"
                f"  Current APY: `{current_apy}%` ‚Üí New APY: `{target_apy}%`\n"
                f"  Profit: `{profit}%` \\(Gas: ${gas}\\)\n"
                f"  Position: `${position}`\n"
            )
            rows.append(row)
        
        footer = f"\nüîî Found *{len(recommendations)}* opportunities"
        return header + '\n'.join(rows) + footer

    def _format_top_apy(self, top_pools: List[Dict]) -> str:
        """Format top APY pools message with improved formatting"""
        header = "‚ú® *TOP STABLE OPPORTUNITIES* ‚ú®\n\n"
        rows = []
        
        for i, pool in enumerate(top_pools[:5], 1):
            asset = self._escape_markdown_v2(pool['asset'])
            chain = self._escape_markdown_v2(pool['chain'])
            protocol_part = pool['pool_id'].split('_')[2]
            protocol_name = protocol_part.split('-')[0].capitalize()
            protocol = self._escape_markdown_v2(protocol_name)
            apy = self._escape_markdown_v2(f"{pool['apy']:.2f}")
            
            # Fix TVL formatting
            tvl_usd = pool['tvl']
            if tvl_usd >= 1_000_000:
                tvl_str = f"${tvl_usd/1_000_000:.1f}M"
            elif tvl_usd >= 1_000:
                tvl_str = f"${tvl_usd/1_000:.1f}K"
            else:
                tvl_str = f"${tvl_usd:,.0f}"
            tvl = self._escape_markdown_v2(tvl_str)
            
            number = self._escape_markdown_v2(f"#{i}")
            
            rows.append(
                f"üèÜ *{number}*\n"
                f"‚îå *Asset*: {asset}\n"
                f"‚îú *Chain*: {chain}\n"
                f"‚îú *Protocol*: {protocol}\n"
                f"‚îú *APY*: `{apy}%`\n"
                f"‚îî *TVL*: `{tvl}`\n"
            )
        
        total = self._escape_markdown_v2(str(len(top_pools)))
        footer = f"\nüîç Found *{total}* high\\-yield pools"
        return header + '\n'.join(rows) + footer

    def send_top_apy_alert(self, top_pools: List[Dict]) -> bool:
        """Send top APY pools alert"""
        if not top_pools:
            logger.info("No top APY pools to send")
            return False
            
        message = self._format_top_apy(top_pools)
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(self._send_message(message))

    def _format_asset_alert(self, asset_data: Dict, title: str) -> str:
        """Generic format for asset alerts"""
        asset = self._escape_markdown_v2(asset_data['asset'])
        chain = self._escape_markdown_v2(asset_data.get('chain', 'Multi-chain'))
        apy = self._escape_markdown_v2(f"{asset_data['apy']:.2f}")
        apy_base = self._escape_markdown_v2(f"{asset_data.get('apyBase', 0):.2f}")
        tvl = self._escape_markdown_v2(f"${asset_data['tvl']/1_000_000:.1f}M")
        protocol = self._escape_markdown_v2(asset_data['pool_id'].split('_')[2].capitalize())

        return (
            f"üèÜ *{title}* üèÜ\n\n"
            f"‚Ä¢ *Asset*: {asset}\n"
            f"‚Ä¢ *Chain*: {chain}\n"
            f"‚Ä¢ *Protocol*: {protocol}\n"
            f"‚Ä¢ *Total APY*: `{apy}%`\n"
            f"‚Ä¢ *Base APY*: `{apy_base}%`\n"
            f"‚Ä¢ *TVL*: `{tvl}`\n"
        )

    def send_top_asset_alerts(self, latest_apy: List[Dict]):
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤—Å–µ—Ö –∞–ª–µ—Ä—Ç–æ–≤"""
        messages = []
        
        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∞–ª–µ—Ä—Ç–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        if self.config['send_overall']:
            top_overall = get_top_asset_overall(latest_apy)
            if top_overall:
                messages.append(self._format_asset_alert(top_overall, "Top Overall Asset"))
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ü–µ–ø–µ–π
        chains_to_process = self.config['send_chains'] or list({p['chain'] for p in latest_apy})
        
        for chain in chains_to_process:
            top_chain = get_top_asset_by_chain(latest_apy, chain)
            if top_chain:
                messages.append(self._format_asset_alert(top_chain, f"Top {chain} Asset"))
        
        # Growing asset
        if self.config['send_growth']:
            top_growth = get_top_growing_asset()
            if top_growth:
                messages.append(self._format_growth_alert(top_growth))
        
        # Top 3 Base APY
        if self.config['send_top3_base']:
            top3_base = get_top3_base_apy(latest_apy)
            if top3_base:
                messages.append(self._format_top3_base_alert(top3_base))
        
        # –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º event loop
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
            results = []
            for i, msg in enumerate(messages):
                # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                if i > 0:
                    time.sleep(3)  # 3 —Å–µ–∫—É–Ω–¥—ã –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                
                results.append(loop.run_until_complete(self._send_message(msg)))
            
            return all(results)
        finally:
            loop.close()

    def _get_growth_data(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ä–æ—Å—Ç–∞ APY —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        if not self._growth_data:
            self._growth_data = get_top_growing_asset()
        return self._growth_data

    def _format_growth_alert(self, growth_data: Dict) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–ª–µ—Ä—Ç–∞ —Ä–æ—Å—Ç–∞ APY"""
        growth = self._escape_markdown_v2(f"+{growth_data['growth']:.2f}%")
        apy_formatted = self._escape_markdown_v2(f"{growth_data['apy']:.2f}")
        return (
            f"üìà *Highest APY Growth (24h)* üìà\n\n"
            f"‚Ä¢ *Asset*: {self._escape_markdown_v2(growth_data['asset'])}\n"
            f"‚Ä¢ *Chain*: {self._escape_markdown_v2(growth_data['chain'])}\n"
            f"‚Ä¢ *Growth*: `{growth}`\n"
            f"‚Ä¢ *Current APY*: `{apy_formatted}%`\n"
        )

    def _format_top3_base_alert(self, top3_base: List[Dict]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ø-3 –±–∞–∑–æ–≤—ã—Ö APY"""
        message = "ü•áü•àü•â *Top 3 Base APY Leaders* ü•áü•àü•â\n\n"
        for i, asset in enumerate(top3_base, 1):
            apy_base_formatted = self._escape_markdown_v2(f"{asset['apyBase']:.2f}")
            tvl_formatted = self._escape_markdown_v2(f"{asset['tvl']/1_000_000:.1f}")
            entry = (
                f"{i}. *{self._escape_markdown_v2(asset['asset'])}* "
                f"({self._escape_markdown_v2(asset['chain'])})\n"
                f"   `{apy_base_formatted}%` "
                f"TVL: `${tvl_formatted}M`\n"
            )
            message += entry
        return message

def send_telegram_alert(recommendations: List[Dict]) -> bool:
    """Legacy function wrapper"""
    return TelegramNotifier().send_alert(recommendations)

def send_top_apy_alert(top_pools: List[Dict]) -> bool:
    """Legacy function wrapper for top APY alert"""
    return TelegramNotifier().send_top_apy_alert(top_pools)

if __name__ == "__main__":
    TelegramNotifier().run_alerting()